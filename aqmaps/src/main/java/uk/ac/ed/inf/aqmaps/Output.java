package uk.ac.ed.inf.aqmaps;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.geojson.LineString;
import com.mapbox.geojson.Point;

public class Output {
	
	private static String[] color_table;
	private static String[] symbol = new String[] {
			"lighthouse",
			"danger",
			"cross"
	};
	
	//set up an array to record the color
	private static void initialize_color() {
		color_table = new String[258];
		var rgb = new String[] {
				"#00ff00",
				"#40ff00",
				"#80ff00",
				"#c0ff00",
				"#ffc000",
				"#ff8000",
				"#ff4000",
				"#ff0000",
				"#000000",
				"#aaaaaa"
		};
		for (int i = 0; i < 8; i++) {
			var index = 32*i;
			for (int j = index; j < index+32; j++) {
				color_table[j] = rgb[i];
			}
		}
		color_table[256] = rgb[8];
		color_table[257] = rgb[9];
	}
	
	//Output a text file that records the flight path of the drone using a 2d array generated by PathFinder.fly()
	//each row in the array represent a move
	//and an array recording the action "reading the sensor"
	public static void txt_file(ArrayList<ArrayList<Double>> flight_path, String date, String month, String year, 
			String xorigin, String yorigin, HashMap<Integer, Integer> read_sensor, ArrayList<SensorReader.Sensor> slist) {
		String path = "";
		var line = "";
		var last = xorigin + "," + yorigin;
		var n = flight_path.get(0).size();
		var sensor = "null";
		int degree;
		for (int i = 1; i < n+1; i++) {
			if (read_sensor.get(i) != null) {
				sensor = slist.get(read_sensor.get(i)).location;
			}
			else sensor = "null";
			degree = (int) (double) flight_path.get(2).get(i-1);
			var current = flight_path.get(0).get(i-1)+","+flight_path.get(1).get(i-1);
			line = i+","+last + ","+degree+","+current+","+sensor+"\n";
			path += line;
			last = current;
		}
		try {
			FileWriter myWriter = new FileWriter("flightpath-" + date + "-" + month + "-" + year + ".txt");
			myWriter.write(path);
		    myWriter.close();
		}	catch (IOException e) {
		    System.out.println("Oops, something went wrong.");
		    e.printStackTrace();
		}
	}
	
	//draw the flight path as LineString using an 2d array generated by PathFinder.fly()
	//row i represents ith move of the drone
	public static String draw_path(String map, ArrayList<ArrayList<Double>> path, String longitude, String latitude) {
        var xorigin = Double.parseDouble(longitude);
        var yorigin = Double.parseDouble(latitude);
		var moves = path.size() != 0 ? path.get(0).size() : 0;
		String ans = "";
		var fc = FeatureCollection.fromJson(map).features();	
		Point before_move, after_move;
		var before_after = new ArrayList<Point>();
		before_move = Point.fromLngLat(xorigin, yorigin);
		before_after.add(before_move);		
		for (int i = 0; i < moves; i++) {
			after_move = Point.fromLngLat(path.get(0).get(i), path.get(1).get(i));
			before_after.add(after_move);	
		}
		var line = LineString.fromLngLats(before_after);
		var feature = Feature.fromGeometry(line);	
		fc.add(feature);
		ans = FeatureCollection.fromFeatures(fc).toJson();
		return ans;
	}
	
	//output the geojson map given the map in Json format
	public static void write_map(String map, String date, String month, String year) {
		try {
			FileWriter myWriter = new FileWriter("readings-" + date + "-" + month + "-" + year + ".geojson");
		    myWriter.write(map);
		    myWriter.close();
		}	catch (IOException e) {
		    System.out.println("Oops, something went wrong.");
		    e.printStackTrace();
		}
	}
	
	//generate a GeoJson map with 33 sensors as 33 points
	public static String generate_map(ArrayList<SensorReader.Sensor> slist, 
			ArrayList<SensorReader.SensorDetails> coorlist, ArrayList<Integer> unvisited) {
		initialize_color();
		var n = slist.size();
		var features = new ArrayList<Feature>();
		for (int i = 0; i < n; i++) {
			var point = Point.fromLngLat(coorlist.get(i).lng(), coorlist.get(i).lat());
			var feature = Feature.fromGeometry(point);
			feature.addStringProperty("marker-size", "medium");
			feature.addStringProperty("location", slist.get(i).location);
			String sym = "";
			int reading;
			var battery = slist.get(i).battery;
			if (battery < 10) {
				sym = symbol[2];
				reading = 256;
			}
			else { reading = (int) Math.round(Double.parseDouble(slist.get(i).reading));}
			if (reading < 128) {
				sym = symbol[0];
			}
			else if (reading < 256) {
				sym = symbol[1];
			}
			else {
				sym = symbol[2];
			}
			for (int j = 0; j < unvisited.size(); j++) {
				if (unvisited.get(j) == i) {
					reading = 257;
				}
			}
			feature.addStringProperty("rgb-string", color_table[reading]);
			feature.addStringProperty("marker-color", color_table[reading]);
			if (reading < 257) feature.addStringProperty("marker-symbol", sym);
			features.add(feature);
		}		
		var map = FeatureCollection.fromFeatures(features);
		return map.toJson();
	}

}
